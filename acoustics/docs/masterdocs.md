# MASTER DOCS FOR MAKING ACOUSTICS SYSTEM

## Goal
本システムのゴールはM5StickCPlus2とHAT（これらを音響モジュールと名付ける）を並列で処理をして、ある空間に独立的に音を響かせることを目的としている。音響モジュールはtoioの上に載せられ、toioのロコモーションに合わせてそれぞれ音色を変えることを想定している（なおこのディレクトリではtoioに関する制御は扱わない）。また、音響モジュールだけではなく、それらの体験をした支えするウーファーや6chスピーカー、パラメトリック・スピーカー（パラメトリック・スピーカーのみ余裕があった場合）の運用を考えている。これらはmacによって駆動したいと考えている。これら全体を音響システムと総称する。最終的には群ロボットの上に乗った音響モジュール（約30-50台）の豊かな音環境を下にした空間的なオーディオ制御を目指したい。

## Requirements
- M5Stick C Plus2
    - Speaker2 Hat(MAX98357) M5StickC Plus
        - Arduino IDEで開発する際はM5Stackボードマネージャで`M5StickCPlus2`ボードを選択し、ライブラリマネージャから`M5StickCPlus2`ドライバと依存ライブラリを導入する。公式リポジトリではこのドライバが非推奨となり、基盤機能は`M5Unified`と`M5GFX`に移行するよう案内されているため、これらを前提ライブラリとして組み込むことが必須。[StickC-Plus2 Arduino Quick Start](https://docs.m5stack.com/en/arduino/m5stickc_plus2/program) / [M5StickCPlus2 Library README](https://github.com/m5stack/M5StickCPlus2)
        - PlatformIOを使う場合は公式ドキュメントに従い、`platform = espressif32@6.7.0`、`board = m5stick-c`の指定に加えてPSRAM対応フラグを有効化し、`M5Unified`を依存ライブラリとして明示する必要がある。特に`-DBOARD_HAS_PSRAM`と`-mfix-esp32-psram-cache-issue`を付与しないとPSRAM初期化に失敗し音声バッファが確保できない点に留意する。[StickC-Plus2 Softwares](https://docs.m5stack.com/en/core/M5StickC%20PLUS2)
        ```ini
        [env:m5stack-stickc-plus2]
        platform = espressif32@6.7.0
        board = m5stick-c
        framework = arduino
        upload_speed = 1500000
        monitor_speed = 115200
        build_flags =
            -DBOARD_HAS_PSRAM
            -mfix-esp32-psram-cache-issue
            -DCORE_DEBUG_LEVEL=5
        lib_deps =
            M5Unified=https://github.com/m5stack/M5Unified
        ``` 
        - USB経由での書き込みにはCH9102用VCPドライバが前提となる。`Failed to write to target RAM`等の転送エラーが出る場合はWindows/MacいずれもCH9102ドライバを再インストールするのが公式推奨。macOSでは`wchmodem`ポートを選択する必要がある。[StickC-Plus2 Arduino Quick Start](https://docs.m5stack.com/en/arduino/m5stickc_plus2/program)
        - StickC-Plus2では電源管理IC(AXP192)が省かれているため、起動後に`HOLD`(GPIO4)を`HIGH`に保持しないと電源が落ちる。RTCウェイクアップ後も同様にHOLD=1を再設定するのがソフト側要件。スリープ／シャットダウンは`BUTTON C`長押しとGPIO4制御で行う。[StickC-Plus2 Power Differences](https://docs.m5stack.com/en/core/M5StickC%20PLUS2)
        - Speaker2 HatはMAX98357ベースのI2Sアンプであり、`BCLK=GPIO26`、`LRCLK=GPIO0`、`DIN=GPIO25(ジャンパでGPIO36に切替可能)`を使う。`M5StickCPlus2` ライブラリの `config.external_speaker.hat_spk2 = true` を設定して `StickCP2.begin()` を呼ぶと、これらのピン割り当てと電源保持が自動で行われる。[Hat SPK2 Doc](https://docs.m5stack.com/en/hat/Hat-SPK2) / [M5StickCPlus2 Examples](https://github.com/m5stack/M5StickCPlus2/tree/master/examples)
        - `M5Unified` + `M5StickCPlus2` ライブラリが HAT SPK2 (MAX98357) 向けの I2S 設定を内包しているため、`StickCP2.begin()` 時に `config.external_speaker.hat_spk2 = true` を立てれば自動で BCLK/LRCLK/DOUT が GPIO26/0/25 に割り当てられる。音声再生は `StickCP2.Speaker.playWav()` 等を用いて WAV データを出力する。ストリーミングが必要な場合は `playRaw()` を使ってバッファを逐次供給する。 [StickCPlus2 library](https://github.com/m5stack/M5StickCPlus2)
        - MAX98357アンプ基板は短絡／過熱保護を備えるが、HatとStickC-Plus2の組み合わせではバス配線が固定されているため、他デバイスとのピン競合がある場合はソフト側でピンモードを適切に初期化し、未使用ピンをINに戻すことが推奨されている。[Hat SPK2 Doc](https://docs.m5stack.com/en/hat/Hat-SPK2)
- Open Sound Control
    - OSCアドレス設計と型シグネチャは最初に決め、sender/receiver双方で同じテーブルを共有する。後から型を変えたくなった場合は`std::variant`等でバージョン互換レイヤを作り、`const_cast`やCスタイルキャストで無理に読み替えない。
    - 受信処理は専用スレッドやタスクに隔離し、所有権を持つバッファを`std::unique_ptr`やリングバッファで管理する。メインスレッドには`const&`で読み取り用データを渡し、「とりあえず`mutable`」やグローバル変数化は避ける。
    - UDP遅延・順序入れ替わりに備えてタイムタグを常に検査し、想定閾値を超えた場合はログとドロップ処理を行う。挙動が不明瞭なまま推測で最適化せず、`ofGetElapsedTimeMicros()`等で処理時間を測定しボトルネックの有無を判断する。
    - パースに失敗したパケットはログ化して破棄し、`reinterpret_cast`で黙って読み進めない。解析用のデバッグログを残し、再送要求やフォールバック経路の有無を検討する。
    - 密集したOSCイベントに対してCPUで逐次波形生成をせず、M5Stick側のI2S/DMAや外部DSPに委譲できないか常に検討する。逆に複雑な状態遷移はCPU側で処理し、GPU/シェーダで無理をしない。

## OSC Timetag Synchrony Concept
- **目的（ゴール）**: 30台のM5StickC Plus2が「同じタイミングで同じ音を鳴らす」ことを実現する。Wi-Fi特有の通信遅延があっても、体感的に同時に聞こえるレベルまでズレを抑える。

### まずは全体像をイメージする
1. **音はM5Stickの中に保存しておく**  
   - それぞれのStickには、短いWAV/PCMファイル（例: 拍子、メロディ断片など）をあらかじめFlash領域（SPIFFS/LittleFS）に入れておく。  
   - 各ファイルには番号（サンプルID）を付け、起動時に表（`SampleRegistry`）を作っておく。
2. **PCが司令塔**  
   - PCが「どのStickが、いつ、どの音を鳴らすか」を決めておき、OSC（Open Sound Control）のメッセージとして送る。  
   - 「すぐ再生」ではなく、「○○ミリ秒後に再生」という未来時刻付きコマンドにするのがポイント。
3. **全員の時計を揃える**  
   - PCをNTPサーバーにして、Stickは起動直後と定期的に時刻同期する。これで全員の時計がほぼ一致する。
4. **OSCバンドル（タイムタグ付き）を送る**  
   - PCは「いまから100ms後にサンプルID=5を鳴らす」といった指示をOSCバンドルに詰め、Timetag（未来時刻）を付けて一斉送信する。  
   - ネットワークの都合で受信タイミングにバラつきがあっても、Stick側は指定された時刻まで待ってから再生するので、結果的に同期が取れる。

### 具体的な役割分担
- **PC（シーケンサー兼NTPサーバー）**
    1. NTPサーバーとしてStickに正しい時間を配る。  
    2. 「SoundTimeline」と呼ぶタイムラインを持ち、`{いつ, どのStick, どのサンプル, どんな設定(gain/pan)}`を整理する。  
    3. 各イベントに対して「少し未来の実行時刻（Texec）」を計算し、OSCバンドルを作成。  
    4. バンドルをブロードキャスト/マルチキャストで一斉送信し、ログや失敗を記録する。
- **M5StickC Plus2（サウンドプレイヤー）**
    1. 起動したらまずPCのNTPサーバーと同期し、自分の時計を合わせる。  
    2. 内部に保存した音ファイルを`SampleRegistry`として準備。  
    3. OSC listenerを起動し、PCからのバンドルを受け取る。  
    4. 受け取った指示に書かれたTimetagと自分の時計を比べ、実行時刻まで`PlaybackQueue`で待機。  
    5. 時刻が来たらI2Sで音を鳴らし、終わったら必要に応じてログや状態報告を行う。

### 通信と安全性のポイント
- **OSC over UDP**を使用し、1回の送信で全台に届くようブロードキャストまたはマルチキャストを利用する。  
- メッセージはバイナリ形式（例: `[sample_id:int][gain:float][pan:float][flags:uint8]`）で送ると、Stick側の解析負荷が軽くなる。  
- Stick起動時に端末ID（MACアドレス＋任意ニックネームなど）をPCへ広告させ、PC側でID/グループごとのターゲットリストを管理する。イベントやCLIから特定ID群へ個別送信できるようデータモデルを拡張する。  
- 暗号化が必要な場合はESP32のハードウェアAES（AES-CTR/AES-GCM）を使い、鍵の配布・更新手順を決めておく。  
- パケット欠損が起きた時に備えて、同じ命令を2回送信する、または簡易ACKチャネルを設けると安心。

### よく出る疑問と答え
- **Q: 本当にズレないの？**  
  - 完全にゼロにはできませんが、タイムタグを未来時刻にして余裕を持って配り、Stick側で待機させることで±数ms程度まで抑えられます。  
  - 許容値（例: ±5ms）を決め、測定して満たさない場合はWi-Fi設定やリードタイムを調整します。
- **Q: 音はどうやって更新する？**  
  - 内蔵Flashの音を差し替える場合は、OTAやセットアップスクリプトで書き換える手順を用意します。外付けmicroSDを使う設計も検討できます。
- **Q: 初心者でも運用できる？**  
  - Stickごとに「起動→時計合わせ→音準備→待機」の流れが自動で動くようにしておき、PC側もGUIやスクリプトで「タイムライン作成→送り出し」ができるようにすれば、作業はかなり簡単になります。

### 仕組みを試すときのチェックリスト（PoC）
1. Stickが正しい時刻をとれているか（NTP同期ログを見る）。  
2. サンプルIDを指定して音が鳴るか（手動でOSCを送ってテスト）。  
3. 3〜5台で試して、再生開始のズレを録音やログで測る。  
4. 結果を`docs/test/osc_sync_results.md`に記録し、問題があれば原因と対策をメモ。  
5. 本番の30台テスト前に、Stick再起動時の再参加手順や、ズレが大きいときのリセット手順を練習しておく。

### 補足: 技術用語を簡単に言い換えると…
- **OSC (Open Sound Control)**: 音響機器向けの軽量な指令フォーマット。数字や文字列をバイナリで送れる。  
- **Timetag**: OSCメッセージに付ける「この時間に実行せよ」という予定時刻。  
- **NTP**: ネットワーク経由で時刻を合わせる仕組み。  
- **SPIFFS/LittleFS**: ESP32上のFlashにファイルを保存する仕組み。  
- **I2S**: デジタルオーディオデータをDACに送るための標準インターフェイス。

### もう少し詳しい設計メモ（上級者向け）
- **PC側**  
    1. `SoundTimeline`でイベント管理。  
    2. `Texec = now + lead_time`を計算。  
    3. OSCバンドル作成（Timetag埋め込み）→ブロードキャスト送信。  
    4. ログ・失敗検知・遅延統計を継続的に記録。
- **M5Stick側**  
    1. NTP同期・サンプル表構築。  
    2. OSC受信→Timetag確認→PlaybackQueue追加。  
    3. FreeRTOSタスクで`Texec`を監視し、I2S再生。割り込み優先度チューニングで安定化。  
    4. 再生完了後に状態ログを残し、必要ならPCへレポート。
- **信頼性向上策**  
    - コマンド冪等設計（同じ命令を2回受けても問題ない構造に）。  
    - Wi-Fi AP専用化、チャンネル固定、干渉排除。  
    - 遅延閾値に達したらアラート → AP設定見直しやリードタイム調整。
- **評価手順**  
    - 小規模PoC → 計測 → ドキュメント記録。  
    - 30台テスト前に、再同期/復旧手順をリハーサル。

## サブシステム別 要件定義

### PC側（シーケンサ／コマンド送出）要件
- **担当範囲**
    - NTPサーバーとしてStick群に基準時刻を配布する。
    - SoundTimelineを編集・保守し、OSCバンドルを生成・送信する。
    - Stickからの状態フィードバックを受けて遅延統計・異常検知を行う。
    - GUI上から接続端末の状態監視・個別制御・即時再生パラメータ調整を提供する。

#### C++ Implementation Roadmap (2025-Q1)
1. **OSC Transport Unification**
    - Heartbeat/announceをOSCメッセージに統一（`/announce`,`/heartbeat`,`/control/*`）。  
    - 既存 `pc_tools/libs/osc` を共通基盤にし、受信専用の `OscListener` と送信 `OscSender` クラスを整備。  
    - Unitテストで `/heartbeat` → 統計集計（monitor）までのパスを検証し、`tests/osc_sync_results.md` 更新ワークフローを確立。
    - UDP処理は `asio` ベースで統一し、暗号層導入のフック（`Encryptor` インターフェース、`NonceGenerator`）を残す。
2. **Device Registry Service**
    - `/announce` 受信時に `devices.json` を自動生成し、GUI/CLI からターゲット選択できる API (`DeviceRegistry`) を提供。  
    - 状態は `DeviceState{id, mac, fw_version, last_seen, heartbeat_stats}` を基本構造にし、プラットフォーム非依存で読み出せるよう `pc_tools/common` に配置。
    - `DeviceRegistry` は `/control/register` 応答を生成し、永続化（`nlohmann::json`）とホットリロードを司る。
3. **Scheduler/Monitor Refactor**
    - 送信機能をライブラリ化し、CLIとGUIの双方から呼び出せる C++ API (`TimelineScheduler::sendBundles`, `HeartbeatMonitor::attach`) を定義。  
    - 旧CLI（`agent_a_scheduler`,`agent_a_monitor`）はラッパーに移行し、ログとエラー処理を共有する。  
    - タイムライン生成、送信ログ、受信統計を `pc_tools/tests` 配下で自動回帰テスト化。
    - `spdlog` + `fmt` を採用し、CLIとGUIで共通のロギングポリシーを共有する。
4. **GUI Prototype (Dear ImGui + ImPlot想定)**
    - レイアウト: 左ペイン=デバイス一覧、右上=タイムラインプレビュー、右下=イベントログ。  
    - 操作: プリセット手動再生、タイムライン送信、Heartbeat遅延グラフを提供。  
    - バックエンドはステップ1-3で提供したC++ APIを利用し、描画ループ内で状態をポーリングする。  
    - 初期リリースは macOS/Windows/Ubuntu 向けスタンドアロンを目標（CMake + GLFWビルドプリセットを追加）。
    - OSCイベントは `IoContextRunner` スレッドで処理し、GUI側はスレッドセーフなスナップショットAPIで参照する。
5. **5台協調PoC**
    - `sound_assets/manifest.json` に5種類のプリセットを定義し、Stick側の `PresetStore` と整合させる。  
    - 1→3→5台の順で再生テストを実施し、GUIで遅延／ドロップ指標を可視化、結果を `tests/osc_sync_results.md`・`tests/load_test.md` に記録。  
    - 課題（Wi-Fi干渉、リードタイム調整、GUI応答性）を `process/issue_template.md` を使って管理する。
    - タイムライン例: `dev-01`→`preset_a`、`dev-02`→`preset_b`、`dev-03`→`preset_c`、`dev-04`→`preset_d`、`dev-05`→`preset_e` の順で3秒間隔再生、ラウンド完了後2秒待機して再ループ。
6. **仕上げと次フェーズ準備**
    - C++ API にドキュメント（Doxygenコメント＋`docs/pc_workflow.md` 追記）を追加。  
    - ビルドプリセット（リリース/デバッグ）とCIジョブを定義し、PR時に単体テスト＋GUI smoke テストを実行。  
    - 暗号層導入のための拡張ポイント（Encryptorインターフェース、nonce管理）を設計し、Q2以降に移行可能な状態を残す。
    - GitHub Actions でクロスプラットフォームビルド（macOS/Windows/Ubuntu）と Catch2 テスト、GUI Smoke テストを自動化する。

- **作業ステップ**
    1. **環境構築**: NTPサーバー設定、OSC送信ライブラリ導入、ネットワーク疎通確認。
    2. **シーケンサ実装**: タイムライン編集UI/CLI、`Texec`算出ロジック、バンドル生成器。
    3. **送出モジュール**: ブロードキャスト／マルチキャスト送信、再送ポリシー、暗号化層（AES-CTR/GCM）。
    4. **モニタリング**: 遅延測定、Stickの心拍メッセージ受信、ログ保存、アラート通知。
    5. **リアルタイムGUI**: デバイス一覧、タイムライン編集、ライブパラメータ調整、手動トリガーを行うGUIを実装し、バックエンドと双方向通信する。
- **テスト計画**
    - *単体テスト*: タイムライン→バンドル生成、暗号化／復号、時刻補正計算。
    - *結合テスト（PC内）*: 送出モジュール＋モニタリングで擬似Stick（モック）に対して動作確認。
    - *インターフェーステスト*: 実機1台を接続し、時刻同期と単発再生を確認。
    - *スモールグループテスト*: 3〜5台相手に遅延測定、再送挙動、エラー復旧を確認。
    - *リリース前テスト*: 30台を想定したリハーサル用シナリオをリプレイし、ログと測定値を評価。
- **成果物**
    - `pc_tools/` 以下のソースコード・README・セットアップ手順。
    - `docs/spec/osc_contract.md`（OSCメッセージ定義）、`docs/process/onboarding.md`（運用手順）、GUI操作マニュアル（`docs/pc_workflow.md`に追記）。
    - モニタリング用ダッシュボード／ログ解析スクリプト。
- **作業者切り分けと進捗報告**
    - NTP・ネットワーク担当、シーケンサ担当、モニタリング担当に分業可能。
    - 各フェーズ完了時にテストログ（CSVやグラフ）を`tests/`配下へコミットし、レビューを受ける。

### M5StickC Plus2側（ファームウェア）要件
- **担当範囲**
    - 起動時にNTP同期を行い、プリセット音源を読み込む。
    - OSCバンドル受信、Timetagに基づく再生キュー管理、I2Sを使った音声再生。
    - リソース解放・状態ログ・再起動時の復旧（再同期／再参加）。
- **作業ステップ**
    1. **環境構築**: PlatformIO/Arduino IDE設定、PSRAM有効化、CH9102ドライバ確認。
    2. **基盤機能**: HOLD(GPIO4)制御、Wi-Fi接続・リトライ、タイム同期、プリセット音読み込み。
    3. **OSC処理**: 受信タスク、暗号化復号、バンドル解析、PlaybackQueue投入。
    4. **再生タスク**: `StickCP2.Speaker` の初期化、I2S駆動、割り込み優先度調整、再生完了後のクリーンアップ。
    5. **フィードバック**: 心拍メッセージ送信、エラー／再生結果の報告、およびログ整形。
- **テスト計画**
    - *単体テスト*: NTP同期、SPIFFS読み込み、OSCパーサ、PlaybackQueue、I2S出力（各モジュール）。
    - *ハードウェア結合テスト*: 1台で起動→再生→停止→再起動の一連操作を確認し、HOLD制御とリソース解放を検証。
    - *小規模インテグレーション*: 3〜5台で同時再生し、ズレ／ドロップを計測。
    - *耐久テスト*: 長時間連続再生、Wi-Fi切断→再接続、再同期処理を検証。
    - *セキュリティ検証*: 暗号化セットアップ、鍵ローテーション手順、偽コマンド拒否の動作確認。
- **成果物**
    - `firmware/` 以下のソース・設定ファイル・ビルド手順。
    - `docs/device_setup.md`（セットアップ）、`docs/troubleshooting.md`（エラー対処）。
    - プリセット音のマニフェスト（`sound_assets/manifest.json`）と更新手順書。
- **作業者切り分けと進捗報告**
    - ネットワーク同期担当、OSC処理担当、音声再生担当などで並列開発が可能。
    - 各テスト完了時にログ／動画／計測結果を`tests/`へ追加し、レビュワーに共有。

### 統合タイミングとリハーサル
1. **個別完成通知**: PC側・M5側が単体／小規模テストを完了した段階で成果物とログを共有。
2. **PoC結合**: 3〜5台を使い、PC→Stickの一連フロー（時刻同期→再生→ログ回収）を合同で確認。
3. **機能凍結**: 仕様変更を止め、ドキュメント・バージョン表を確定。
4. **本番スケール検証**: 30台前提のシナリオをリハーサルし、遅延・ドロップ・復旧手順を訓練。
5. **ローンチ準備**: 最終手順書（セットアップ／運用／エスカレーション）を`process/`配下にまとめ、関係者へ周知。

### エージェント向け作業指示書
- **Agent A (OSC/PCシーケンサ担当)**: `acoustics/agents/agent_A/README.md`
- **Agent B (M5StickC Plus2ファームウェア担当)**: `acoustics/agents/agent_B/README.md`

各担当は上記READMEを起点に作業を進め、完了した成果物・ログを該当ディレクトリへ配置する。

## 想定される問題とコーディング上の注意

- **音声ストリーミングは対象外**
    - ESP32単体でリアルタイムの大容量音声ストリーミングを安定させるのは困難なため、このシステムではすべての音素材をStick内にプリロードする設計を維持する。PC→Stick間で送るのは制御コマンドのみ。
- **デバイスIDの一意性とドリフト**
    - MACアドレス＋カスタム名を用いても、再フラッシュ時にラベルが変わる恐れがある。ID管理ファイル(`devices.json`)の更新フローとバックアップを設計する。
    - IDに紐づく設定が残っていると誤送信につながるため、削除済みIDは定期的にクリーンアップする。
- **NTP同期ずれ**
    - Wi-Fi輻輳や電源断で時計がずれることがある。Stick側は定期的な再同期と心拍メッセージで誤差をレポートし、PC側は閾値を超えたらアラートを上げる。
    - Timetagが過去のものだった場合の扱い（破棄 or 補正）を明確に実装し、ログへ記録する。
- **パケット欠損・重複**
    - UDPなので欠損/重複が起こり得る。コマンドは冪等に設計し、`sequence_id` などで重複検知を行う。
    - 同じ命令を二重送信する場合、再生キューが2件にならないようGuardを入れる。
- **暗号と鍵管理**
    - AES鍵をコードにベタ書きしない。環境変数や安全な設定ファイルから読み込む。
    - 鍵ローテーション時には、旧鍵を受け付ける猶予を設け、切替ログを残す。
- **GUIとバックエンドの整合性**
    - GUIからの操作がバックエンドCLIと衝突しないよう、排他制御またはイベントキューを導入する。
    - GUIで変更したタイムラインが保存されない、反映されないケースを防ぐため、保存前後の状態をログに残し、Undo/Redo設計を検討する。
- **M5Stick側の割り込み・タスク管理**
    - Wi-FiタスクとI2S再生タスクが競合すると音割れや再起動を誘発する。FreeRTOS優先度とバッファサイズを適切に調整する。
    - 再生中に新しいコマンドが届いた場合の挙動（後ろに積む／割り込み停止）を仕様化して実装する。
- **電源・HOLD制御の抜け漏れ**
    - HOLD(GPIO4)をLOWにすると電源断するため、テストコードで誤って落とさないようガードする。
    - 大量同時スタート時の突入電流も考慮し、外部給電やUSBハブの耐性を確認する。
- **ログと計測の肥大化**
    - 30台からのログを集約するとサイズが膨れ上がる。ローテーション、圧縮、古いログ削除を自動化する。
    - 計測スクリプトは時刻付きで保存し、同じテスト条件を再現できるようにする。
- **テスト漏れ**
    - 単体テストだけでなく、ID別ターゲティング、GUI操作、ネットワーク切断・再接続などの異常系を必ずシナリオ化して`tests/`に保管する。

## Coding Rules
- **データ所有と責務分離**
    - `ofApp.h`に変数を安易に追加しない。OSC受信、音響レンダリング、UI、ログなどの責務ごとに専用クラスを定義し、データ所有者を明確にする。
    - 共有が必要な情報は`const&`で読み取り専用として公開し、書き込みが必要な場合のみ`&`を渡す。`mutable`の乱用は禁止。
- **キャスト禁止事項**
    - `const_cast`、Cスタイルキャスト`((Type*)p)`、`reinterpret_cast`を使った“とりあえず動かす”対応を禁止する。型不一致が発生したら設計（インターフェースやポリモーフィズム、`std::variant`）を見直す。
    - APIの`const`制約を外したい場合は、なぜ`const`なのかを検証し、設計変更を優先する。
- **メモリ管理とRAII**
    - 所有権を伴う生ポインタを禁止。`std::unique_ptr`で単一所有、共有が必要な場合は`std::shared_ptr`を使用し、RAIIでリソース寿命を管理する。
    - 外部リソース（ファイル、ソケット、バッファ、シェーダ、FBOなど）は作成と同じスコープで確実に解放されるようラッパークラス化する。
- **CPU/GPU・周辺機能の役割分担**
    - ピクセル処理や重いDSP処理をCPUのforループで済ませない。GPUまたはESP32のI2S/DMA、周辺機能へオフロードできるか常に検討する。
    - 逆に、複雑な状態管理や条件分岐をシェーダに押し込めない。CPU側で制御しやすい設計を優先する。
- **パフォーマンス計測**
    - 「たぶん速い／遅い」で判断しない。`ofGetElapsedTimeMicros()`等で処理時間を計測し、ボトルネック特定後に最適化する。
    - OSCやI2S処理のスループットが足りない場合は、ログとメトリクスを元にボトルネックの所在（ネットワーク・メインループ・オーディオタスク）を明確にする。
- **ドキュメント・リファレンス重視**
    - 仕様が不明なAPIは必ず公式ドキュメントかヘッダを確認してから利用する。推測ベースの呼び出しや副作用無視は禁止。
    - 参照した資料（データシート、GitHubサンプル、ブログ等）は課題チケットやドキュメントにURLで明記し、後追い可能にする。
- **リソースの“死”まで見届ける**
    - `setup()`で生成したオブジェクトは`exit()`やデストラクタで必ず破棄する。`new`したら`delete`、`malloc`したら`free`ではなく、ライフサイクルをクラスで管理する（RAII徹底）。
    - Wi-Fiやオーディオストリームの停止処理（`StickCP2.Speaker.stop()`、`WiFi.disconnect(true)`など）を忘れず、長期運用でリソースリークが起きないようにする。

## Task List
1. OSCインターフェース設計を完了する
    - 目標:sender/receiver双方が共有するOSCアドレス・型シグネチャ表とタイムタグ仕様を確定し、ドキュメント化する。
    - 必須要件:型互換レイヤ(`std::variant`等)の方針、パケット破損時の破棄ルール、遅延計測方法を明文化し、測定用ログ出力を設計に含める。
    - 詳細ToDo:
        1. 既存資料・参考実装を読み、必要なパラメータ（音量、パン、再生IDなど）を洗い出して一覧化する。
        2. 各パラメータごとにOSCアドレス、型、許容値範囲、既定値、更新頻度を定義し、Markdownにまとめレビュー依頼を出す。
        3. 遅延測定・補正指針（時刻ソース、閾値、補正アルゴリズム）を設計図に書き込み、チーム合意を取る。
        4. 不正パケット処理フロー（破棄条件・ログ形式・再送方針）をフローチャート化し、Notion/Repoの設計ページに反映する。
        5. 確定した仕様を共有リポジトリの`docs/spec/osc_contract.md`に反映し、アルバイト含む全員への周知ミーティングで説明する。
2. PC側OSCディスパッチャを実装・検証する
    - 目標:専用スレッドでOSC受信し、所有権管理されたリングバッファを介してメインループに`const&`でデータを渡す構造を構築する。
    - 必須要件:危険キャスト禁止(Cスタイル/`const_cast`/`reinterpret_cast`)、処理時間の計測とログ出力、CPU/GPU役割分担の検証(重い処理はGPU/別タスクへ委譲可否を見直す)。
    - 詳細ToDo:
        1. 受信モジュールのクラス図を描き、責務分離ポリシー（受信→解析→配布）を設計レビューで確定する。
        2. Boost.Asio等のOSCライブラリ選定理由を比較表にまとめ、採用決定後にセットアップ手順をREADMEに追記する。
        3. リングバッファ実装時に`std::unique_ptr`で所有権を管理し、push/pop時のロック方針（mutex or lock-free）を決め性能評価する。
        4. 処理時間計測のために`ofGetElapsedTimeMicros()`でラップした計測コードを追加し、メトリクスをCSVで出力する仕組みを作る。
        5. 危険キャスト禁止の静的解析ルール（clang-tidyなど）をCIに組み込み、簡単なサンプルでCIが通ることを確認する。
        6. ユニットテストで異常系（破損パケット・遅延超過）を再現し、期待通りドロップ・ログ出力されるか検証する。
3. M5StickC Plus2ファームウェアを実装する
    - 目標:`M5Unified`/`M5GFX`ベースでI2S出力とOSC受信を統合し、HOLD(GPIO4)制御とSPK2設定(`config.external_speaker.hat_spk2`)を行う。
    - 必須要件:PSRAMフラグ設定済みビルド環境(PlatformIO/Arduino)を整備し、CH9102ドライバ確認、`M5Unified`/`M5StickCPlus2` 導入、Wi-Fi接続の確立と異常時リソース解放。
    - 詳細ToDo:
        1. PlatformIO環境構築手順をスクリーンショット付きでドキュメント化し、新人用オンボードタスクとしてチケット化する。
        2. `platformio.ini`にPSRAM設定、`lib_deps`を追加し、サンプルビルドでPSRAMが有効になっているかシリアルログで確認する。
        3. ファームコードでHOLD(GPIO4)の初期化・スリープ復帰処理を実装し、動作確認（電源落ちないこと、再起動シナリオ）を動画で残す。
        4. `StickCP2.Speaker` で SPK2 が鳴ることを確認する運用手順（音声ファイル、期待音）を記録する。
        5. Wi-Fi接続・切断シナリオをテストし、タイムアウト発生時に`StickCP2.Speaker.stop()`や`WiFi.disconnect(true)`が呼ばれることをログで検証する。
        6. ファームの例外/エラーハンドリング方針をREADMEに追記し、アルバイト向けトラブルシュート手順をまとめる。
4. 統合テストと性能検証を実施する
    - 目標:PC↔M5Stick間でOSC連携した状態で音声再生を行い、遅延・ドロップ率を計測して許容閾値と比較する。
    - 必須要件:計測データをログ化し、タイムタグ補正/再送方針を評価。CPU負荷・I2Sバッファ枯渇・メモリ使用量を監視し、設計改善事項を洗い出す。
    - 詳細ToDo:
        1. テストケース表を作成し、シナリオ（通常遅延、遅延大、パケット欠損、複数台同時）ごとの合格基準を明記する。
        2. 計測用スクリプトを準備し、遅延・ドロップ率・CPU使用率を自動採取してCSV/グラフ生成まで行う簡易ダッシュボードを作る。
        3. 測定結果に基づき、閾値を超えた項目について原因調査コメントと改善策（例:バッファサイズ変更、Wi-Fiチャンネル変更）を記載する。
        4. テスト環境セットアップ手順（配線図、IP設定、電源管理）を写真付きでWikiにまとめ、だれでも再現できるようにする。
        5. テスト後はログ・計測データを共有ストレージに保管し、レポートをPull Requestに添付してレビュー依頼する。
5. 運用準備とドキュメント整備を行う
    - 目標:複数台(toio搭載想定)展開時の手順書、OSCアドレス表、ビルド環境手順、リソース掃除手順(停止・再起動)をまとめる。
    - 必須要件:参照資料URLを付記し、チーム全体で遵守するコーディングルールとチェックリストを明示。動作確認済みファーム/PCソフトのバージョン管理を整備する。
    - 詳細ToDo:
        1. セットアップから運用、停止、トラブルシュートまでの手順書をステップごとに分解し、アルバイトがチェックボックスで進められるようテンプレート化する。
        2. コーディングルール・レビュー項目・IssueテンプレートをGitリポジトリ内`docs/process/`に配置し、Onboardingセッションで説明する。
        3. ファームウェア、PCソフト、依存ライブラリ、ドライバのバージョン表を作成し、更新時の手順（検証→展開→周知）を定めてSlack等で告知する。
        4. ハードウェア在庫、シリアル番号、使用履歴をスプレッドシートで管理し、貸し出し/返却手順を決めて運用する。
        5. 追加開発やバグフィックスが発生した際のエスカレーションルート（誰に報告・どのIssueテンプレートを使うか）を明文化する。

### Step/Deliverable Details
- **Step 1 Deliverables**
    - 完成したOSCアドレス/型シグネチャ表（Markdownまたはスプレッドシート）
    - パケット破損・遅延時の処理フローチャート
    - シミュレータやテストスクリプトで送受信を検証するためのモックコード
- **Step 2 Deliverables**
    - PC側受信モジュールのクラス設計図と実装(`Receiver`, `Dispatcher`, バッファ管理クラス)
    - 処理時間・遅延を記録するメトリクスログサンプル
    - 危険キャスト使用がないことを示すコードレビュー記録
- **Step 3 Deliverables**
    - PlatformIO/Arduino設定ファイル（`platformio.ini`や`.ino`）と依存ライブラリ一覧
    - HOLD制御・I2Sピン設定を行うファームウェアコードとユニットテスト
    - Wi-Fi接続・異常時リカバリを検証したログ、リソース解放手順書
- **Step 4 Deliverables**
    - 遅延・ドロップ率・CPU/I2Sバッファ使用率を示す測定レポート
    - 許容閾値を満たさない場合の改善策リストと対応優先度
    - テスト環境構成図（ネットワーク・電源・使用デバイス）
- **Step 5 Deliverables**
    - 展開マニュアル(初期セットアップ→運用→停止手順)
    - コーディングルールチェックリスト、レビュー手順、Issueテンプレート
    - バージョン表（ファームウェア・PCアプリ・依存ライブラリ・ドライバ）


## アイディア
- 時刻動機の方法としてNTPとかRTPを用いてRTCのズレがないことを祈りながら指示をおくるなど？
- 
